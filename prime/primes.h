#ifndef _PRIMES_H
#define _PRIMES_H

#include "bit_array.h"

// Define underlying type for calculations
#define P_INT unsigned long long

// Use Sieve of Eratosthenes to check primality of all numbers up to size
P_INT prime_sieve(unsigned char *primality, P_INT size);
// USe Sieve of Eratosthenes to check primality of all numbers up to size
// Storing result into the bit array primality
P_INT prime_sieve_bs(bits_t primality, P_INT size);

typedef struct pwheel_s *pwheel_t;
extern pwheel_t PWHEEL_6, PWHEEL_30;

pwheel_t make_pwheel(unsigned char max);
void free_pwheel(pwheel_t whl);

// Get the head element of the array of primes for whl
unsigned char *fstprm_w(pwheel_t whl);
// Get the last element of the array of primes for whl
unsigned char *lstprm_w(pwheel_t whl);

/* Macro for looping over all primes used to generate the wheel
 * 
 * Arguments:
 *   unsigned char *p : pointer to prime to store primes in
 *   pwheel_t w : wheel to iterate over
 */
#define for_primes_w(p, w) for(p = fstprm_w(w); p <= lstprm_w(w); (p)++)

/* Moves inc and x to the next increment and number respectivly
 * or Initialize inc and x if *inc == NULL
 * 
 * Usage:
 *   unsigned char *inc = NULL;
 *   P_INT x, n = 10391;
 *   for(nextnum_w(&inc, &x, whl); x * x <= n; nextnum_w(&inc, &x, whl)){
 *       // Iterate through all possible primes less than sqrt(n)
 *       // Do stuff with possible prime x
 *   }
 * 
 * Arguments:
 *   unsigned char **inc : pointer to inc pointer which will be
 *     pointed to the next increment
 *     NOTE: If *inc == NULL then inc and x will be initialized
 *   P_INT *x : pointer to x value to set as the next number
 *     generated by the wheel
 *   pwheel_t whl : wheel to use to move inc and x
 * 
 * Returns: void
 */
void nextnum_w(unsigned char **inc, P_INT *x, pwheel_t whl);

/* Macro for looping over increments and numbers generated by wheel
 * 
 * Arguments:
 *   unsigned char *inc : pointer to current increment
 *   P_INT x : location to store the number generated by the wheel
 *   pwheel_t w : wheel to iterate over
 *   expression cond : expression to place in the second argument to the for loop
 */
#define for_nums_w(inc, x, w, cond) inc = NULL; for(nextnum_w(&(inc), &(x), w); cond; nextnum_w(&(inc), &(x), w))



/* Checks whether a number is prime using wheel factorization
 * 
 * Arguments:
 *   P_INT x : number to check for primality
 *   pwheel_t whl : wheel to use to check for primality
 *      NOTE: The builtins PWHEEL_6 or PWHEEL_30 may be used for whl
 * 
 * Returns:
 *   int : Boolean indicating primality, 1 -> Is Prime ; 0 -> Is Composite
 */ 
int is_prime_w(P_INT x, pwheel_t whl);


/* Factorizes number using wheel factorization
 * Each call will return the next factor with its power
 * 
 * Usage:
 *   P_INT x = 540;   // 540 == (2 * 2) * (3 * 3 * 3) * 5
 *   int pow;
 *   factorize_w(x, PWHEEL_6, &pow);  // Returns 2 ; Sets pow = 2
 *   factorize_w(0, NULL, &pow);    // Returns 3 ; Sets pow = 3
 *   factorize_w(0, NULL, &pow);    // Returns 5 ; Sets pow = 1
 *   factorize_w(0, NULL, &pow);    // Returns 0
 * 
 * Arguments:
 *   P_INT x : number to factorize
 *      NOTE: Use x = 0 to get continued factors
 *   pwheel_t whl : wheel to use to check for primality
 *      NOTE: The builtins PWHEEL_6 or PWHEEL_30 may be used for whl
 *   int *pow : pointer to location to store power of prime factor
 * 
 * Returns:
 *   P_INT : prime factor or 0 if number is completely factored
 *   int *pow : exponent on prime factor
 */
P_INT factorize_w(P_INT x, pwheel_t whl, int *pow);

/* Check primality of x using Miller Rabin method
 * with wits as the witnesses. Because it is a probabilistic
 * method this method can have false positives
 * given certain arguments.
 * 
 * Usage:
 *   P_INT witnesses[] = {10, 11, 15};
 *   P_INT x = 571; // Prime number
 *   is_prime_mr(571, 3, witnesses);   // 571 prime => Returns 1
 *   is_prime_mr(672, 3, witnesses);   // 672 composite => Returns 0
 *   is_prime_mr(8911, 3, witnesses);  // 8911 composite => Returns 1
 * 
 * Arguments:
 *   P_INT x : number to be checked for primality
 *   size_t wits_len : number of witnesses in wits
 *   wits: witnesses to check x against
 * 
 * Returns:
 *   int : boolean value indicate if x is prime
 */
int is_prime_mr(P_INT x, size_t wits_len, P_INT *wits);

/* Check primality of x using Fermat's Algorithm
 * checking N = a^2 - b^2 for a between sqrt(N)
 * and sqrt(N) * (1 + above_sqrt).
 *
 * Usage:
 *   is_prime_fmt(9551, PWHEEL_6, 0.2);  // 9551 prime => Returns 1
 *
 * Arguments:
 *   P_INT x : number to be checked for primality
 *   pwheel_t whl : Wheel used to generate potential divisors
 *     for trial division
 *   float above_sqrt : Proportion above sqrt(x) to search
 * 
 * Returns:
 *   int : boolean value indicating if x is prime
 */
int is_prime_fmt(P_INT x, pwheel_t whl, float above_sqrt);

#endif
